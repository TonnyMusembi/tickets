// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const assignTicket = `-- name: AssignTicket :exec
UPDATE tickets
SET assigned_to = ?, updated_at = NOW()
WHERE id = ?
`

type AssignTicketParams struct {
	AssignedTo sql.NullInt64 `db:"assigned_to"`
	ID         int64         `db:"id"`
}

func (q *Queries) AssignTicket(ctx context.Context, arg AssignTicketParams) error {
	_, err := q.exec(ctx, q.assignTicketStmt, assignTicket, arg.AssignedTo, arg.ID)
	return err
}

const createCustomer = `-- name: CreateCustomer :execresult
INSERT INTO customers (full_name, email, phone_number)
VALUES (?, ?, ?)
`

type CreateCustomerParams struct {
	FullName    string `db:"full_name"`
	Email       string `db:"email"`
	PhoneNumber string `db:"phone_number"`
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (sql.Result, error) {
	return q.exec(ctx, q.createCustomerStmt, createCustomer, arg.FullName, arg.Email, arg.PhoneNumber)
}

const createOTP = `-- name: CreateOTP :execresult
INSERT INTO otp_codes (profile_id, otp_code, expires_at)
VALUES (?, ?, ?)
`

type CreateOTPParams struct {
	ProfileID int32     `db:"profile_id"`
	OtpCode   string    `db:"otp_code"`
	ExpiresAt time.Time `db:"expires_at"`
}

func (q *Queries) CreateOTP(ctx context.Context, arg CreateOTPParams) (sql.Result, error) {
	return q.exec(ctx, q.createOTPStmt, createOTP, arg.ProfileID, arg.OtpCode, arg.ExpiresAt)
}

const createProfile = `-- name: CreateProfile :execresult
INSERT INTO profiles (full_name, phone, password_hash)
VALUES (?, ?, ?)
`

type CreateProfileParams struct {
	FullName     sql.NullString `db:"full_name"`
	Phone        string         `db:"phone"`
	PasswordHash string         `db:"password_hash"`
}

func (q *Queries) CreateProfile(ctx context.Context, arg CreateProfileParams) (sql.Result, error) {
	return q.exec(ctx, q.createProfileStmt, createProfile, arg.FullName, arg.Phone, arg.PasswordHash)
}

const createTicket = `-- name: CreateTicket :execresult
INSERT INTO tickets (title, description, created_by, priority, status)
VALUES (?, ?, ?, ?, ?)
`

type CreateTicketParams struct {
	Title       string `db:"title"`
	Description string `db:"description"`
	CreatedBy   int64  `db:"created_by"`
	Priority    string `db:"priority"`
	Status      int16  `db:"status"`
}

func (q *Queries) CreateTicket(ctx context.Context, arg CreateTicketParams) (sql.Result, error) {
	return q.exec(ctx, q.createTicketStmt, createTicket,
		arg.Title,
		arg.Description,
		arg.CreatedBy,
		arg.Priority,
		arg.Status,
	)
}

const createTransaction = `-- name: CreateTransaction :execresult
INSERT INTO transactions (transaction_id, user_id,amount,currency,status,payment_method)
VALUES(?,?,?,?,?,?)
`

type CreateTransactionParams struct {
	TransactionID string         `db:"transaction_id"`
	UserID        int32          `db:"user_id"`
	Amount        string         `db:"amount"`
	Currency      string         `db:"currency"`
	Status        int16          `db:"status"`
	PaymentMethod sql.NullString `db:"payment_method"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (sql.Result, error) {
	return q.exec(ctx, q.createTransactionStmt, createTransaction,
		arg.TransactionID,
		arg.UserID,
		arg.Amount,
		arg.Currency,
		arg.Status,
		arg.PaymentMethod,
	)
}

const createUser = `-- name: CreateUser :execresult
INSERT INTO users (full_name, email,  role)
VALUES (?, ?, ?)
`

type CreateUserParams struct {
	FullName string        `db:"full_name"`
	Email    string        `db:"email"`
	Role     NullUsersRole `db:"role"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (sql.Result, error) {
	return q.exec(ctx, q.createUserStmt, createUser, arg.FullName, arg.Email, arg.Role)
}

const deleteExpiredOTPs = `-- name: DeleteExpiredOTPs :exec
DELETE FROM otp_codes
WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredOTPs(ctx context.Context) error {
	_, err := q.exec(ctx, q.deleteExpiredOTPsStmt, deleteExpiredOTPs)
	return err
}

const getCustomerByEmail = `-- name: GetCustomerByEmail :one
SELECT id, full_name, email, phone_number, created_at FROM customers
WHERE email = ? LIMIT 1
`

func (q *Queries) GetCustomerByEmail(ctx context.Context, email string) (Customer, error) {
	row := q.queryRow(ctx, q.getCustomerByEmailStmt, getCustomerByEmail, email)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.PhoneNumber,
		&i.CreatedAt,
	)
	return i, err
}

const getCustomers = `-- name: GetCustomers :many
SELECT id, full_name, email, phone_number, created_at FROM customers LIMIT ? OFFSET ?
`

type GetCustomersParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

func (q *Queries) GetCustomers(ctx context.Context, arg GetCustomersParams) ([]Customer, error) {
	rows, err := q.query(ctx, q.getCustomersStmt, getCustomers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Customer{}
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.Email,
			&i.PhoneNumber,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestOTPByProfileID = `-- name: GetLatestOTPByProfileID :one
SELECT id, profile_id, otp_code, expires_at, verified, attempts, created_at
FROM otp_codes
WHERE profile_id = ?
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestOTPByProfileID(ctx context.Context, profileID int32) (OtpCode, error) {
	row := q.queryRow(ctx, q.getLatestOTPByProfileIDStmt, getLatestOTPByProfileID, profileID)
	var i OtpCode
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.OtpCode,
		&i.ExpiresAt,
		&i.Verified,
		&i.Attempts,
		&i.CreatedAt,
	)
	return i, err
}

const getProfileByPhone = `-- name: GetProfileByPhone :one

SELECT id, phone, password_hash, full_name, created_at, updated_at
FROM profiles
WHERE phone = ?
`

// db/queries.sql
func (q *Queries) GetProfileByPhone(ctx context.Context, phone string) (Profile, error) {
	row := q.queryRow(ctx, q.getProfileByPhoneStmt, getProfileByPhone, phone)
	var i Profile
	err := row.Scan(
		&i.ID,
		&i.Phone,
		&i.PasswordHash,
		&i.FullName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTicket = `-- name: GetTicket :one
SELECT id, title, description, status, priority, created_by, assigned_to, created_at, updated_at FROM tickets
WHERE id = ? LIMIT 1
`

func (q *Queries) GetTicket(ctx context.Context, id int64) (Ticket, error) {
	row := q.queryRow(ctx, q.getTicketStmt, getTicket, id)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.Priority,
		&i.CreatedBy,
		&i.AssignedTo,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTicketByTitleAndUser = `-- name: GetTicketByTitleAndUser :one
SELECT id, title, description, status, priority, created_by, assigned_to, created_at, updated_at FROM tickets
WHERE title = ? AND created_by = ?
LIMIT 1
`

type GetTicketByTitleAndUserParams struct {
	Title     string `db:"title"`
	CreatedBy int64  `db:"created_by"`
}

func (q *Queries) GetTicketByTitleAndUser(ctx context.Context, arg GetTicketByTitleAndUserParams) (Ticket, error) {
	row := q.queryRow(ctx, q.getTicketByTitleAndUserStmt, getTicketByTitleAndUser, arg.Title, arg.CreatedBy)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.Priority,
		&i.CreatedBy,
		&i.AssignedTo,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransanctionByID = `-- name: GetTransanctionByID :one
SELECT id, transaction_id, user_id, amount, currency, status, payment_method, created_at, updated_atFROM transactions
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetTransanctionByID(ctx context.Context, id int32) (Transaction, error) {
	row := q.queryRow(ctx, q.getTransanctionByIDStmt, getTransanctionByID, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.UserID,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.PaymentMethod,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, full_name, email, password, role, created_at FROM users
WHERE email = ? LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.queryRow(ctx, q.getUserByEmailStmt, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByEmailExcludingID = `-- name: GetUserByEmailExcludingID :one
SELECT id, full_name, email, password, role, created_at FROM users
WHERE email = ? AND id != ?
LIMIT 1
`

type GetUserByEmailExcludingIDParams struct {
	Email string `db:"email"`
	ID    int64  `db:"id"`
}

func (q *Queries) GetUserByEmailExcludingID(ctx context.Context, arg GetUserByEmailExcludingIDParams) (User, error) {
	row := q.queryRow(ctx, q.getUserByEmailExcludingIDStmt, getUserByEmailExcludingID, arg.Email, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, full_name, email, password, role, created_at FROM users
WHERE id = ? LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.queryRow(ctx, q.getUserByIDStmt, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.CreatedAt,
	)
	return i, err
}

const incrementOTPAttempts = `-- name: IncrementOTPAttempts :exec
UPDATE otp_codes
SET attempts = attempts + 1
WHERE id = ?
`

func (q *Queries) IncrementOTPAttempts(ctx context.Context, id int32) error {
	_, err := q.exec(ctx, q.incrementOTPAttemptsStmt, incrementOTPAttempts, id)
	return err
}

const listTickets = `-- name: ListTickets :many
SELECT
    id,
    title,
    description,
    status,
    priority,
    created_by,
    assigned_to,
    created_at,
    updated_at
FROM tickets
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListTicketsParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

func (q *Queries) ListTickets(ctx context.Context, arg ListTicketsParams) ([]Ticket, error) {
	rows, err := q.query(ctx, q.listTicketsStmt, listTickets, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Ticket{}
	for rows.Next() {
		var i Ticket
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.Priority,
			&i.CreatedBy,
			&i.AssignedTo,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactions = `-- name: ListTransactions :many
SELECT
id,
transaction_id,
amount,
currency,
payment_method
FROM transactions
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListTransactionsParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

type ListTransactionsRow struct {
	ID            int32          `db:"id"`
	TransactionID string         `db:"transaction_id"`
	Amount        string         `db:"amount"`
	Currency      string         `db:"currency"`
	PaymentMethod sql.NullString `db:"payment_method"`
}

func (q *Queries) ListTransactions(ctx context.Context, arg ListTransactionsParams) ([]ListTransactionsRow, error) {
	rows, err := q.query(ctx, q.listTransactionsStmt, listTransactions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTransactionsRow{}
	for rows.Next() {
		var i ListTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.TransactionID,
			&i.Amount,
			&i.Currency,
			&i.PaymentMethod,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT
    id,
    full_name,
    email,
    role,
    created_at
FROM users
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListUsersParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

type ListUsersRow struct {
	ID        int64         `db:"id"`
	FullName  string        `db:"full_name"`
	Email     string        `db:"email"`
	Role      NullUsersRole `db:"role"`
	CreatedAt sql.NullTime  `db:"created_at"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]ListUsersRow, error) {
	rows, err := q.query(ctx, q.listUsersStmt, listUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUsersRow{}
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.Email,
			&i.Role,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markOTPVerified = `-- name: MarkOTPVerified :exec
UPDATE otp_codes
SET verified = TRUE
WHERE id = ?
`

func (q *Queries) MarkOTPVerified(ctx context.Context, id int32) error {
	_, err := q.exec(ctx, q.markOTPVerifiedStmt, markOTPVerified, id)
	return err
}

const updateTicketStatus = `-- name: UpdateTicketStatus :exec
UPDATE tickets
SET status = ?, updated_at = NOW()
WHERE id = ?
`

type UpdateTicketStatusParams struct {
	Status int16 `db:"status"`
	ID     int64 `db:"id"`
}

func (q *Queries) UpdateTicketStatus(ctx context.Context, arg UpdateTicketStatusParams) error {
	_, err := q.exec(ctx, q.updateTicketStatusStmt, updateTicketStatus, arg.Status, arg.ID)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET
  full_name = ?,
  email     = ?,
  role      = ?
WHERE id = ?
`

type UpdateUserParams struct {
	FullName string        `db:"full_name"`
	Email    string        `db:"email"`
	Role     NullUsersRole `db:"role"`
	ID       int64         `db:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.exec(ctx, q.updateUserStmt, updateUser,
		arg.FullName,
		arg.Email,
		arg.Role,
		arg.ID,
	)
	return err
}
