// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const assignTicket = `-- name: AssignTicket :exec
UPDATE tickets
SET assigned_to = ?, updated_at = NOW()
WHERE id = ?
`

type AssignTicketParams struct {
	AssignedTo sql.NullInt64 `db:"assigned_to"`
	ID         int64         `db:"id"`
}

func (q *Queries) AssignTicket(ctx context.Context, arg AssignTicketParams) error {
	_, err := q.exec(ctx, q.assignTicketStmt, assignTicket, arg.AssignedTo, arg.ID)
	return err
}

const createTicket = `-- name: CreateTicket :execresult
INSERT INTO tickets (title, description, created_by, priority,status)
VALUES (?, ?, ?, ?,?)
`

type CreateTicketParams struct {
	Title       string `db:"title"`
	Description string `db:"description"`
	CreatedBy   int64  `db:"created_by"`
	Priority    string `db:"priority"`
	Status      int16  `db:"status"`
}

func (q *Queries) CreateTicket(ctx context.Context, arg CreateTicketParams) (sql.Result, error) {
	return q.exec(ctx, q.createTicketStmt, createTicket,
		arg.Title,
		arg.Description,
		arg.CreatedBy,
		arg.Priority,
		arg.Status,
	)
}

const createUser = `-- name: CreateUser :execresult
INSERT INTO users (full_name, email,  role)
VALUES (?, ?, ?)
`

type CreateUserParams struct {
	FullName string        `db:"full_name"`
	Email    string        `db:"email"`
	Role     NullUsersRole `db:"role"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (sql.Result, error) {
	return q.exec(ctx, q.createUserStmt, createUser, arg.FullName, arg.Email, arg.Role)
}

const getTicket = `-- name: GetTicket :one
SELECT id, title, description, status, priority, created_by, assigned_to, created_at, updated_at FROM tickets
WHERE id = ? LIMIT 1
`

func (q *Queries) GetTicket(ctx context.Context, id int64) (Ticket, error) {
	row := q.queryRow(ctx, q.getTicketStmt, getTicket, id)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.Priority,
		&i.CreatedBy,
		&i.AssignedTo,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTicketByTitleAndUser = `-- name: GetTicketByTitleAndUser :one
SELECT id, title, description, status, priority, created_by, assigned_to, created_at, updated_at FROM tickets
WHERE title = ? AND created_by = ?
LIMIT 1
`

type GetTicketByTitleAndUserParams struct {
	Title     string `db:"title"`
	CreatedBy int64  `db:"created_by"`
}

func (q *Queries) GetTicketByTitleAndUser(ctx context.Context, arg GetTicketByTitleAndUserParams) (Ticket, error) {
	row := q.queryRow(ctx, q.getTicketByTitleAndUserStmt, getTicketByTitleAndUser, arg.Title, arg.CreatedBy)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.Priority,
		&i.CreatedBy,
		&i.AssignedTo,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, full_name, email, password, role, created_at FROM users
WHERE email = ? LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.queryRow(ctx, q.getUserByEmailStmt, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByEmailExcludingID = `-- name: GetUserByEmailExcludingID :one
SELECT id, full_name, email, password, role, created_at FROM users
WHERE email = ? AND id != ?
LIMIT 1
`

type GetUserByEmailExcludingIDParams struct {
	Email string `db:"email"`
	ID    int64  `db:"id"`
}

func (q *Queries) GetUserByEmailExcludingID(ctx context.Context, arg GetUserByEmailExcludingIDParams) (User, error) {
	row := q.queryRow(ctx, q.getUserByEmailExcludingIDStmt, getUserByEmailExcludingID, arg.Email, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, full_name, email, password, role, created_at FROM users
WHERE id = ? LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.queryRow(ctx, q.getUserByIDStmt, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.CreatedAt,
	)
	return i, err
}

const listTickets = `-- name: ListTickets :many
SELECT 
    id,
    title,
    description,
    status,
    priority,
    created_by,
    assigned_to,
    created_at,
    updated_at
FROM tickets
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListTicketsParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

func (q *Queries) ListTickets(ctx context.Context, arg ListTicketsParams) ([]Ticket, error) {
	rows, err := q.query(ctx, q.listTicketsStmt, listTickets, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Ticket{}
	for rows.Next() {
		var i Ticket
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.Priority,
			&i.CreatedBy,
			&i.AssignedTo,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT 
    id,
    full_name,
    email,
    role,
    created_at
FROM users
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListUsersParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

type ListUsersRow struct {
	ID        int64         `db:"id"`
	FullName  string        `db:"full_name"`
	Email     string        `db:"email"`
	Role      NullUsersRole `db:"role"`
	CreatedAt sql.NullTime  `db:"created_at"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]ListUsersRow, error) {
	rows, err := q.query(ctx, q.listUsersStmt, listUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUsersRow{}
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.Email,
			&i.Role,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTicketStatus = `-- name: UpdateTicketStatus :exec
UPDATE tickets
SET status = ?, updated_at = NOW()
WHERE id = ?
`

type UpdateTicketStatusParams struct {
	Status int16 `db:"status"`
	ID     int64 `db:"id"`
}

func (q *Queries) UpdateTicketStatus(ctx context.Context, arg UpdateTicketStatusParams) error {
	_, err := q.exec(ctx, q.updateTicketStatusStmt, updateTicketStatus, arg.Status, arg.ID)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET 
  full_name = ?,
  email     = ?,
  role      = ?
WHERE id = ?
`

type UpdateUserParams struct {
	FullName string        `db:"full_name"`
	Email    string        `db:"email"`
	Role     NullUsersRole `db:"role"`
	ID       int64         `db:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.exec(ctx, q.updateUserStmt, updateUser,
		arg.FullName,
		arg.Email,
		arg.Role,
		arg.ID,
	)
	return err
}
